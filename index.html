<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Sakura Tilt Demo</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #0b1020; }
      canvas { display: block; width: 100vw; height: 100vh; }

      .ui {
        position: fixed;
        left: 12px; right: 12px; top: 12px;
        display: flex; gap: 10px; align-items: center; justify-content: space-between;
        color: #fff; font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        z-index: 10;
        pointer-events: none;
      }
      .panel {
        pointer-events: auto;
        background: rgba(0,0,0,0.35);
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 12px;
        padding: 10px 12px;
        backdrop-filter: blur(6px);
      }
      button {
        appearance: none;
        border: 0;
        border-radius: 10px;
        padding: 10px 12px;
        font-weight: 700;
        color: #0b1020;
        background: #ffd6e6;
        cursor: pointer;
      }
      .small { font-size: 12px; opacity: 0.85; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    </style>
  </head>

  <body>
    <div class="ui">
      <div class="panel small">
        <div><b>ğŸŒ¸ Sakura Tilt Demo</b></div>
        <div class="mono" id="debug">sensor: -</div>
        <div class="small">ç«¯æœ«ã‚’å‚¾ã‘ã‚‹ã¨è½ä¸‹æ–¹å‘ãŒå°‘ã—æ–œã‚ã«ãªã‚Šã¾ã™</div>
      </div>

      <div class="panel">
        <button id="btn">å‹•ãã‚’è¨±å¯</button>
      </div>
    </div>

    <canvas id="c"></canvas>

    <script>
      // ====== Canvas setup ======
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");

      function resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.floor(innerWidth * dpr);
        canvas.height = Math.floor(innerHeight * dpr);
        canvas.style.width = innerWidth + "px";
        canvas.style.height = innerHeight + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      }
      addEventListener("resize", resize);
      resize();

      // ====== Sakura particles ======
      const PETAL_COUNT = 90;
      const petals = [];
      const rand = (a, b) => a + Math.random() * (b - a);

      function resetPetal(p, fromTop = true) {
        p.x = rand(0, innerWidth);
        p.y = fromTop ? rand(-innerHeight * 0.2, 0) : rand(0, innerHeight);
        p.size = rand(6, 14);
        p.fall = rand(40, 90);       // base fall speed (px/s)
        p.drift = rand(-15, 15);     // small personal drift (px/s)
        p.rot = rand(0, Math.PI * 2);
        p.rotSpeed = rand(-2.2, 2.2);
        p.wobblePhase = rand(0, Math.PI * 2);
        p.wobbleAmp = rand(4, 16);   // wobble in x
        p.wobbleSpeed = rand(0.6, 1.6);
        p.alpha = rand(0.6, 0.95);
      }

      for (let i = 0; i < PETAL_COUNT; i++) {
        const p = {};
        resetPetal(p, false);
        petals.push(p);
      }

      // èŠ±ã³ã‚‰ã‚’ã€Œãã‚Œã£ã½ãã€æãï¼ˆå˜ç´”ãªãƒ‘ã‚¹ï¼‰
      function drawPetal(x, y, size, rot, alpha) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);
        ctx.globalAlpha = alpha;

        // ã»ã‚“ã®ã‚Šã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        const g = ctx.createRadialGradient(-size * 0.2, -size * 0.2, 1, 0, 0, size * 1.4);
        g.addColorStop(0, "rgba(255, 210, 230, 0.95)");
        g.addColorStop(1, "rgba(255, 150, 190, 0.85)");
        ctx.fillStyle = g;

        ctx.beginPath();
        // ã—ãšãå‹ + ã¸ã“ã¿ã‚’ä½œã‚‹
        ctx.moveTo(0, -size);
        ctx.bezierCurveTo(size * 0.9, -size * 0.9, size * 1.2, size * 0.2, 0, size);
        ctx.bezierCurveTo(-size * 1.2, size * 0.2, -size * 0.9, -size * 0.9, 0, -size);
        ctx.closePath();
        ctx.fill();

        // çœŸã‚“ä¸­ã®ç­‹
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.9);
        ctx.lineTo(0, size * 0.9);
        ctx.stroke();

        ctx.restore();
      }

      // ====== Sensor: accelerationIncludingGravity ======
      const debugEl = document.getElementById("debug");

      // é‡åŠ›æ–¹å‘ï¼ˆç«¯æœ«åº§æ¨™ã® g æˆåˆ†ï¼‰â†’ ç”»é¢å†…ã®å‚¾ãã«åæ˜ 
      // â€»æ¨ªæ–¹å‘ã‚’å°‘ã—ã ã‘åŠ¹ã‹ã›ãŸã„ã®ã§ gain ã‚’æ§ãˆã‚ã«ã—ã¦ã„ã¾ã™
      let tiltX = 0; // -1..1 ãã‚‰ã„ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼ˆå·¦/å³ã®å‚¾ãï¼‰
      let tiltY = 0;

      // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆæ€¥ãªãƒ–ãƒ¬ã‚’ãªã‚‰ã™ï¼‰
      const smooth = (prev, next, k) => prev + (next - prev) * k;

      function onMotion(e) {
        const a = e.accelerationIncludingGravity;
        if (!a) return;

        // iOS/Androidã§è»¸ã®å‘ããŒé•ã„å¾—ã‚‹ã®ã§ã€ã€Œã¨ã‚Šã‚ãˆãšå‹•ãã€å‰æã®ç°¡æ˜“ãƒãƒƒãƒ—
        // ç«¯æœ«ã‚’å·¦å³ã«å‚¾ã‘ã‚‹ã¨ x ãŒå¤‰åŒ–ã—ã‚„ã™ã„æƒ³å®š
        const ax = a.x ?? 0;
        const ay = a.y ?? 0;
        const az = a.z ?? 0;

        // g â‰’ 9.8 ã‚’åŸºæº–ã«æ­£è¦åŒ–
        const nx = Math.max(-1, Math.min(1, ax / 9.8));
        const ny = Math.max(-1, Math.min(1, ay / 9.8));

        tiltX = smooth(tiltX, nx, 0.12);
        tiltY = smooth(tiltY, ny, 0.12);

        debugEl.textContent = `accG x:${ax.toFixed(2)} y:${ay.toFixed(2)} z:${az.toFixed(2)} | tiltX:${tiltX.toFixed(2)}`;
      }

      // iOS 13+ ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§è¨±å¯ãŒå¿…è¦
      const btn = document.getElementById("btn");
      btn.addEventListener("click", async () => {
        try {
          if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
            const res = await DeviceMotionEvent.requestPermission();
            if (res !== "granted") {
              btn.textContent = "è¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ";
              return;
            }
          }
          window.addEventListener("devicemotion", onMotion, { passive: true });
          btn.textContent = "è¨±å¯OK âœ…";
          btn.disabled = true;
        } catch (err) {
          console.error(err);
          btn.textContent = "å¤±æ•—ã—ã¾ã—ãŸ";
        }
      });

      // ====== Animation loop ======
      let last = performance.now();

      function tick(now) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;

        // èƒŒæ™¯ï¼ˆã»ã‚“ã®ã‚Šï¼‰
        ctx.clearRect(0, 0, innerWidth, innerHeight);
        ctx.fillStyle = "rgba(11,16,32,1)";
        ctx.fillRect(0, 0, innerWidth, innerHeight);

        // å‚¾ã â†’ è½ä¸‹ãƒ™ã‚¯ãƒˆãƒ«ã¸åæ˜ 
        // ã“ã“ãŒè‚ï¼šxæ–¹å‘ã®é€Ÿåº¦ã« tiltX ã‚’å°‘ã—ã ã‘è¶³ã™ï¼ˆæ–œã‚ã«æµã‚Œã‚‹ï¼‰
        const wind = tiltX * 90;          // px/sï¼ˆå·¦å³å‚¾ãã§é¢¨ãŒå¤‰ã‚ã‚‹ï¼‰
        const gravityBoost = (tiltY * -20); // ä¸Šä¸‹å‚¾ãã§è½ä¸‹ãŒå°‘ã—å¤‰ã‚ã‚‹ï¼ˆæ§ãˆã‚ï¼‰

        for (const p of petals) {
          p.wobblePhase += p.wobbleSpeed * dt;

          const wobble = Math.sin(p.wobblePhase) * p.wobbleAmp;
          const vx = p.drift + wind;
          const vy = p.fall + gravityBoost;

          p.x += (vx * dt) + wobble * dt;
          p.y += vy * dt;
          p.rot += p.rotSpeed * dt;

          // ç”»é¢å¤–ã«å‡ºãŸã‚‰ä¸Šã«æˆ»ã™
          if (p.y > innerHeight + 30 || p.x < -60 || p.x > innerWidth + 60) {
            resetPetal(p, true);
            // é¢¨ãŒå¼·ã„æ™‚ã¯ç«¯ã‹ã‚‰å…¥ã£ã¦ãã‚‹æ„Ÿã˜ã«
            if (wind > 30) p.x = rand(-30, innerWidth * 0.2);
            if (wind < -30) p.x = rand(innerWidth * 0.8, innerWidth + 30);
          }

          drawPetal(p.x, p.y, p.size, p.rot, p.alpha);
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    </script>
  </body>
</html>
